{% extends "layout.html" %}

{% block chatbot %}
<!-- Start of Async Drift Code -->
<script>
!function() {
  var t;
  if (t = window.driftt = window.drift = window.driftt || [], !t.init) return t.invoked ? void (window.console && console.error && console.error("Drift snippet included twice.")) : (t.invoked = !0,
  t.methods = [ "identify", "config", "track", "reset", "debug", "show", "ping", "page", "hide", "off", "on" ],
  t.factory = function(e) {
    return function() {
      var n;
      return n = Array.prototype.slice.call(arguments), n.unshift(e), t.push(n), t;
    };
  }, t.methods.forEach(function(e) {
    t[e] = t.factory(e);
  }), t.load = function(t) {
    var e, n, o, i;
    e = 3e5, i = Math.ceil(new Date() / e) * e, o = document.createElement("script"),
    o.type = "text/javascript", o.async = !0, o.crossorigin = "anonymous", o.src = "https://js.driftt.com/include/" + i + "/" + t + ".js",
    n = document.getElementsByTagName("script")[0], n.parentNode.insertBefore(o, n);
  });
}();
drift.SNIPPET_VERSION = '0.3.1';
drift.load('s2rst4h926mg');
</script>
<!-- End of Async Drift Code -->
{% endblock %}

{% block body %}

<div class="row"><div class="col-md-6 col-md-offset-3">
  <h1>Clean Data</h1>
  <p class="lead">Authorized users can visually clean data here.<br />This step is important for assuring data quality.</p>

  <form id="qaqc2">
    <div class="col-md-8">
      <select placeholder="Choose a site" id="dsite" name="site">
        <option value="">Choose a site</option>
        {% for sv, sn in sites %}
        <option value="{{sv}}">{{sn}}</option>
        {% endfor %}
      </select>
    </div>
    <div class="col-md-4">
      <button name="qaqcsite" class="btn btn-primary btn-block">Select</button>
    </div>
  </form>
</div></div>

<br>

<div class="row" id="flagging">

<div class="row text-center">
  <div class="col-md-12">
    <div class="panel panel-default">
      <div class="panel-body">
        <div class="form-inline">
        Show local night-time: <input type="checkbox" id="shownight" value="no"> &nbsp;
        <!-- Aggregation: <select class="form-control" id="timescale" name="timescale">
          <option value="15m" selected>15 minutes (default)</option>
          <option value="1h">1 hour</option>
          <option value="1d">1 day</option></select> &nbsp; -->
        <!-- Fill down marking brush: <input type="checkbox" id="fillbrush" value="yes"> &nbsp; -->
        Compare variable: <select class="form-control" id="backgraphlist" name="backgraphlist"></select>
        <br>
        <!-- <button class="btn btn-danger" type="button" id="addna">Set NA values</button> -->
        <!-- <button class="btn btn-primary" type="button" id="zoomin">Zoom in to selected region</button> -->
        <button class="btn btn-link" type="button" id="zoomreset">Reset zoom</button>
        (Can also double-click any plot to reset)
        </div>
        <p> NOTES: flag type resets to "Questionable" after each operation.<br>
          "Apply to all variables" works. It just doesn't register visually until you reload the page.<br>
          Fixes for these issues and for general sluggishness coming soon.</p>
      </div>
    </div>
  </div>
</div>

<div class="row"> <!-- this chunk now just used as a placeholder -->
  <!-- <div class="col-md-3">
  </div>
  <div class="col-md-6">
    <div class="panel panel-default">
      <div class="panel-heading"><span class="lead">Data Flagging</span> &ndash; Label points of interest or concern. </div>
      <div class="panel-body">
        <select id="flags" placeholder="Choose a flag" name="flagID">
          <option value="">Choose (or enter) a flag ID</option>
          {% for f in flags %}
          <option value="{{f}}">{{f}}</option>
          {% endfor %}
        </select>
        <input type="text" name="fcomment" class="form-control" placeholder='Add optional comments (e.g. "Sensor out of water")'>
        <button class="btn btn-warning btn-block" type="button" id="addflag">Flag selected</button>
      </div>
    </div>
  </div> -->

<!--  <div class="col-md-6">
    <div class="panel panel-default">
      <div class="panel-heading"><span class="lead">Tags/notes</span> &ndash; interesting features in the data (storms, leaf drop, etc.)</div>
      <div class="panel-body">
        <select id="tags" placeholder="Choose (or enter) a tag ID (alphanumeric with no spaces please)" name="tagID">
          <option value="">Choose (or enter) a tag ID</option>
          {% for t in tags %}
          <option value="{{f}}">{{t}}</option>
          {% endfor %}
        </select>
        <input type="text" name="fcomment" class="form-control" placeholder="Add comments (optional)">
        <button class="btn btn-info btn-block" type="button" id="addtag">Tag selected</button>
      </div>
    </div>
  </div> -->
</div>

<div class="container-fluid">
  <div class="row">
    <div class="col-md-4 text-left">
      <button class="btn btn-link" type="button" id="panback">
        << Previous four weeks
      </button>
    </div>
    <div class="col-md-4 text-center">
      <p>Jump to date range: </p>
      <select class="form-control" id="jumptodate" name="jumptodate">
      </select>
    </div>
    <div class="col-md-4 text-right">
      <button class="btn btn-link" type="button" id="panforward">
        Next four weeks >>
      </button>
    </div>
  </div>
</div>

</div>


<div class="row" id="graphs"></div>


<script src="static/js/graphs.js"></script>
<script>
$('#dsite').selectize({
    delimiter: ',',
    persist: false,
    create: function(input) { return {value: input,text: input} }
});

$('#flags2').selectize({
    delimiter: ',',
    persist: false,
    create: function(input) { return {value: input,text: input} }
});

//$('#tags').selectize({
//    delimiter: ',',
//    persist: false,
//    create: function(input) { return {value: input,text: input} }
//});

var plotdates;
var alldata;
// var alldatna;
var plotstart;
var plotend;

//for subsetting time series by desired window
function getdisplaydata(start, end, dat){
  stdt = Date.parse(start) //convert from YYYY-MM-DD to unix
  endt = Date.parse(end)
  pltdat = $(dat).filter(function(i,n){
    return Date.parse(n.DateTime_UTC)>stdt && Date.parse(n.DateTime_UTC)<endt
  })
  return $.makeArray(pltdat)
}

//generate plots and additional asynchronous options
$(function(){
  $("button[name=qaqcsite]").click(function(){
    var dat = {}
    dat['site'] = $('select[name=site]').val();

    $.ajax({
      type: 'POST',
      url:'/_getqaqc',
      data: JSON.stringify(dat),
      contentType: 'application/json;charset=UTF-8',
      success: function(response){
        $("#graphs").empty();
        plotdates = response.plotdates; // list of 4-week window boundaries
        alldata = JSON.parse(response.dat);
        plotstart = plotdates[1];
        plotend = plotdates[0];
        data = getdisplaydata(plotstart, plotend, alldata);

        //reformat plot dates as DD/MM/YYYY, remove leading zeros on D and M
        plotdates_reform = plotdates.slice(0) //copy mutable array
        for (var i = 0; i < plotdates_reform.length; ++i){
          splt = plotdates_reform[i].split('-')
          plotdates_reform[i] = splt[1].replace(/^0/, '') + '/' +
            splt[2].replace(/^0/, '') + '/' + splt[0]
        }

        $.ajax({
          type: 'POST',
          url: '/_outlierdetect',
          data: JSON.stringify(data),
          contentType: 'application/json;charset=UTF-8',
          success: function(response2){
            outliers = response2.outliers;
            variables = response.variables;
            sundat = JSON.parse(response.sunriseset);
            sundat.forEach(function(d){
              d.rise = parseDate(d.rise);
              d.set = parseDate(d.set);
            });
            flags = JSON.parse(response.flagdat);
            Plots(variables, data, flags, outliers, "qaqc");
            if($("#shownight").is(":checked")) { Sunlight(variables, sundat) };
            $('#flagging').show();

            //populate dropdown of potential comparison variables
            $('#backgraphlist')
              .find('option').remove().end()
              .append('<option value="None" selected>None</option>');
            for (var i = 0; i < response.variables.length; ++i){
              $('#backgraphlist').append('<option value="'+response.variables[i]+'">'+response.variables[i]+'</option>');
            }

            //populate dropdown of potential date ranges to jump to
            //this establishes the selected option
            default_range = plotdates_reform[1] + ' - ' + plotdates_reform[0]
            default_range_val = plotdates[1] + ' ' + plotdates[0]
            $('#jumptodate')
              .find('option').remove().end()
              .append('<option value="' + default_range_val +
                '" selected>' + default_range + '</option>');

            //and now the rest of the options
            for (var i = 1; i < plotdates_reform.length-1; ++i){
              daterange = plotdates_reform[i+1] + ' - ' + plotdates_reform[i]
              daterange_val = plotdates[i+1] + ' ' + plotdates[i]
              $('#jumptodate').append('<option value="' + daterange_val +
                '">' + daterange + '</option>');
            }

          },
          error: function(error){
            console.log(error);
          }
        });

      },
      error: function(error){
        console.log(error);
      }
    });
    return false;
  })
});

//function ajaxtest(){
//  $.ajax({
//    type: 'POST',
//    url: '/_outlier_detect',
//    data: data,
//    contentType: 'application/json;charset=UTF-8',
//    success: function(response2){
//      outliers = response2.outliers //a list of lists of outliers for each variable, perhaps?
//      console.log(String(outliers)); //make sure this arrangement works
//    },
//    error: function(error){
//      console.log(error);
//    }
//  });
//}

// $(function(){
//   $("#zoomin").click(function(){
//     redrawPoints(zoom_in = true, sbrush=selectedBrush, reset=false)
//   });
// })

//zoomin
$('body').ready(function(){
  $('body').on("click", "#zoomin", function(){
    redrawPoints(zoom_in=true, sbrush=selectedBrush, reset=false)
  });
});

//zoomreset
$(function(){
  $("#zoomreset").click(function(){
    redrawPoints(zoom_in=true, sbrush=selectedBrush, reset=true)
  });
})

//jumptodate
$(function(){
  $('#jumptodate').change(function(){
    daterange_val = this.value
    daterange_vals = daterange_val.split(' ')
    data = getdisplaydata(daterange_vals[0], daterange_vals[1], alldata);
    async_replot(data=data)
  })
})

$(function(){
  $("#backgraphlist").change(function () {
    var backfill = this.value;
    for (var i = 0; i < variables.length; ++i) {
      BackGraph(backfill, variables[i], data);
    }
  });
})

function async_replot(data){
  $.ajax({
    type: 'POST',
    url: '/_outlierdetect',
    data: JSON.stringify(data),
    contentType: 'application/json;charset=UTF-8',
    success: function(response){
      outliers = response.outliers;
      $("#graphs").empty();
      Plots(variables, data, flags, outliers, "qaqc");
      if($("#shownight").is(":checked")) { Sunlight(variables, sundat) };
    },
    error: function(error){
      console.log(error);
    }
  });
}

//panback
$(function(){
  $("#panback").click(function(){

    // if the start date is not the last date in the list (i.e. the oldest)
    if(plotstart != plotdates.slice(-1)[0]){
      plotend = plotstart;
      plotstart = plotdates[plotdates.indexOf(plotstart) + 1];
      // if(datna != null){
      //   data = getdisplaydata(plotstart,plotend,alldatna);
      // }else{
      data = getdisplaydata(plotstart, plotend, alldata);
      // }
      async_replot(data=data)
    }
  });
})

//panforward
$(function(){
  $("#panforward").click(function(){
    if(plotend != plotdates[0]){
      // if the end date is not the first date in the list
      plotstart = plotend;
      plotend = plotdates[plotdates.indexOf(plotend)-1];
      // if(datna != null){
      //   data = getdisplaydata(plotstart,plotend,alldatna);
      // }else{
      data = getdisplaydata(plotstart,plotend,alldata);
      // }
      async_replot(data=data)
    }
  });
})

//alertbox
function alertbox(alrt,msg){
  return '<div class="alert alert-dismissible alert-'+alrt+'">\
    <button class="close" data-dismiss="alert" aria-label="close">&times;</button>\
    '+msg+'</div>'
}


//addna
// $(function(){
//   $("#addna").click(function(){
//     if (undefined != selectedBrush){ // only do this if there is a brush selected
//       s = d3.brushSelection(d3.select("#"+selectedBrush).node())
//       dat = {}
//       dat['site'] = $('select[name=site]').val();
//       dat['startDate'] = x.invert(s[0]);
//       dat['endDate'] = x.invert(s[1]);
//       dat['var'] = selectedBrush;
//       $.ajax({
//         type: 'POST',
//         url:'/_addna',
//         data: JSON.stringify(dat),
//         contentType: 'application/json;charset=UTF-8',
//         success: function(response){
//           console.log("success")
//           $("#alerts").append(alertbox('success','Added NA values.'))
//           alldatna = JSON.parse(response.dat);
//           datna = getdisplaydata(plotstart,plotend,alldatna);
//           redrawPoints(zoom_in=false, sbrush=selectedBrush, reset=false)
//         },
//         error: function(error){
//           console.log(error);
//         }
//       });
//       return false;
//     }else{
//       $("#alerts").append(alertbox('warning','Please select points to add NAs.'))
//     }
//   });
// })

//add flags when static button is clicked
// $(function(){
//   $("#addflag").click(add_flag);
// });

// add flags for all highlighted points when popup button is clicked
$('body').ready(function(){
  $('body').on("click", "#addflag2", function(){
    add_flag(red_points_only=false);
  });
});
// $(document).on('click', '#addflag2', function(){
//   add_flag(red_points_only=false);
// });

// add flags for red highlighted points when popup button is clicked
$('body').ready(function(){
  $('body').on("click", "#addflag_outl", function(){
    add_flag(red_points_only=true);
  });
});
// $(document).on('click', '#addflag_outl', function(){
//   add_flag(red_points_only=true);
// });

function add_flag() {
  if(undefined != selectedBrush){ // only do this if there is a brush selected
    s = d3.brushSelection(d3.select("#"+selectedBrush).node())
    dat = {}
    dat['site'] = $('select[name=site]').val();
    dat['startDate'] = x.invert(s[0]);
    dat['endDate'] = x.invert(s[1]);
    if(brushdown){
      dat['var'] = variables;
      b = d3.selectAll("svg").selectAll(".selected");
      if(red_points_only){
        b = b.filter('.maybe_outl');
      }
      b.classed('highlighted', function(d) {
        is_brushed = dat['startDate'] <= d.date && d.date <= dat['endDate'];
        return is_brushed;
      });
    } else {
      dat['var'] = [selectedBrush];
      b = d3.select("."+selectedBrush).selectAll(".selected");
      if(red_points_only){
        b = b.filter('.maybe_outl');
      }
      b.classed('highlighted', function(d) {
        is_brushed = dat['startDate'] <= d.date && d.date <= dat['endDate'];
        return is_brushed;
      });
    }
    brushdown = false;
    dat['comment'] = $("input[name=fcomment2]").val();
    dat['flagid'] = $("select[name=flagID2]").val();
    if(red_points_only){
      so = d3.select("."+selectedBrush).selectAll(".selected")
      .filter('.maybe_outl').data(); //extract selected outliers
      counter = 0; //prepare for flag_ajax_serial recursion
      dat['startDate'] = so[counter].DateTime_UTC; //focus on first red point
      dat['endDate'] = so[counter].DateTime_UTC;
    }
    if (dat.flagid != null){
      if(red_points_only){
        flag_ajax_serial(counter, so);
      } else {
        flag_ajax_batch();
      }
      return false;
    } else {
      $("#alerts").append(alertbox('warning','Please select a flag type.'));
    }
  } else {
    $("#alerts").append(alertbox('warning','Please select points to add Flags.'));
  }
}

//flag all selected points, the fast way
function flag_ajax_batch(){
  $.ajax({
    type: 'POST',
    url:'/_addflag',
    data: JSON.stringify(dat),
    contentType: 'application/json;charset=UTF-8',
    // success: function(response){
    success: function(){
      $('.popupbox').remove();
      console.log("success");
      $("#alerts").append(alertbox('success','Added flag.'));
    },
    error: function(error){
      $('.popupbox').remove();
      console.log(error);
    }
  });
}

//flag only selected points that are red. waits for callbacks
function flag_ajax_serial(counter, selection){
  $.ajax({
    type: 'POST',
    url:'/_addflag',
    data: JSON.stringify(dat),
    contentType: 'application/json;charset=UTF-8',
    // success: function(response){
    success: function(){
      if (counter < so.length - 1){
        counter++;
        dat['startDate'] = so[counter].DateTime_UTC; //focus on next red point
        dat['endDate'] = so[counter].DateTime_UTC;
        flag_ajax_serial(counter, so);
      } else {
        $('.popupbox').remove();
        $("#alerts").append(alertbox('success','Added flag.'));
      }
    },
    error: function(error){
      $('.popupbox').remove();
      console.log(error);
    }
  });
}

//$(function(){
//  $("#addtag").click(function(){
//    if (undefined != selectedBrush){ // only do this if there is a brush selected
//      s = d3.brushSelection(d3.select("#"+selectedBrush).node())
//      dat = {}
//      dat['site'] = $('select[name=site]').val();
//      dat['startDate'] = x.invert(s[0]);
//      dat['endDate'] = x.invert(s[1]);
//      dat['var'] = selectedBrush;
//      dat['tagid'] = $("select[name=tagID]").val();
//      dat['comment'] = $("input[name=fcomment]").val();
//      d3.select("."+selectedBrush).selectAll(".selected").classed("highlighted", function(d) {
//        is_brushed = dat['startDate'] <= d.date && d.date <= dat['endDate'];
//        return is_brushed;
//      });
//      $.ajax({
//        type: 'POST',
//        url:'/_addtag',
//        data: JSON.stringify(dat),
//        contentType: 'application/json;charset=UTF-8',
//        success: function(response){
//          console.log("success")
//          $("#alerts").append(alertbox('success','Added tag.'))
//        },
//        error: function(error){
//          console.log(error);
//        }
//      });
//      return false;
//    }else{
//      $("#alerts").append(alertbox('warning','Please select values to add Tags/Notes.'))
//    }
//  })
//});

// $(function(){
//   $('#fillbrush').change(function() {
//     if($(this).is(":checked")) {
//       brushdown = true;
//     }else{
//       brushdown = false;
//     }
//   });
// })

//fillbrush
$('body').ready(function(){ //delegated event handler for filldown brush
  $('body').on('change', '#fillbrush', function(){
    if($(this).is(":checked")){
      brushdown = true;
    }else{
      brushdown = false;
    }
  });
});

</script>

{% endblock %}
